<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>Shell 的基本介绍、常用命令以及 Shell 的流程控制 - Documents</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">Documents</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../shell编程训练营/index.html" class="breadcrumb-item">shell编程训练营</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../shell编程训练营/1. Shell 的基本介绍、常用命令以及 Shell 的流程控制.html" class="breadcrumb-item">我们为什么要学习shell</a></div><h1 class="article-title">Shell 的基本介绍、常用命令以及 Shell 的流程控制</h1><div class="article"><h1 id="我们为什么要学习shell">我们为什么要学习shell <a class="markdownIt-Anchor" href="#我们为什么要学习shell">#</a></h1><p>当你遇到了服务器内存占用过多导致卡死的情况，你会怎么办？度娘or谷歌，你得到了这样的答案</p><blockquote><p>查看占用 cpu/内存 资源最多的进程并杀死</p></blockquote><p>对啊，占用多了就干掉啊！</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64qyqg2d9j204e03ma9w.jpg" alt=""><figcaption>“表情包 没错”的图片搜索结果</figcaption></figure><p>但怎么干？习惯图形化界面的咱们找不到删除图标啊！！！没关系，度娘or谷歌，你得到了这样的答案（下面命令执行后会删除占用内存最多的两个进程）</p><pre class="hljs"><code>ps aux|sort -rn -k +3|head -2  | awk &#x27;{print $2}&#x27; | xargs kill -9
</code></pre><p>看懂是不可能看懂的，这辈子是不可能看懂的。</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64r0sm5baj203m03mt8j.jpg" alt=""><figcaption>images</figcaption></figure><p>抱着【试试就试试，反正不会怀孕】的态度，你登陆了shell并且执行了，然后你惊喜的发现，成了！腰也不酸了腿也不疼了，比新盖中盖都好使。</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64r2k6mijg20fc09x4qr.gif" alt=""><figcaption>herMpRO97KmEdF11ei8EySeZkeLP8Mrs</figcaption></figure><p>至此，你的问题得以解决，好学的同学可能会深入学习一番（关于此命令的详解咱们放在文末），然后随着时间推移，短期记忆海马体突触消散而告终。此文结束。。。。。慢着QAQ，问一句，下次再出现这个情况咋办？再找一遍吗？我们陷入了循环</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64r35d6n3j203x03mq2r.jpg" alt=""><figcaption>images (1)</figcaption></figure><p>显然，我们需要破除循环。怎么破除？想想我们熟悉的高级语言怎么解决这个问题的，封装呀，以js为例，各种稀奇古怪的操作被封装在一个又一个的库里，工具库的lodash、网络请求的axios等等，函数名取的清晰易懂，取来即可。这才是我们想要的效果。</p><p>可linux是命令啊，一个个命令用分号或者管道符链接执行，咋封装？而且对于【批量执行命令】这个需求而言，用这两种方法真的不会感觉很冗长吗？这就迎来了我们的主角：shell语言</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64r3od79sj204k04kwed.jpg" alt=""><figcaption>主角表情包搜索-斗图表情包搜索-biaoqing233.com</figcaption></figure><p>让我们来看看对于shell而言怎么实现上面的需求：删除占用内存最多的两个进程</p><ol><li>创建shell文件，作为函数库，假定取名为<code>shell-libs.sh</code></li><li>定义对应函数，假定取名为<code>killProcessByMemory</code>，实现功能为，传递进程数n，杀死占用内存排名前n位进程</li><li>引入函数库文件：<code>source shell-libs.sh</code></li></ol><p>shell-libs.sh</p><pre class="hljs"><code>function arr_includes () {
    local name=$1
    eval local innerArr=(\${${name}[@]})
    local item=$2
    if [[ &quot;${innerArr[@]}&quot;  =~ &quot;${item}&quot; ]]; then
        echo 0
    else
        echo 1
    fi
}
function boolean () {
    local bool=1
    if [[ $1 == 0 ]]; then
        # source ../install/git/git.sh
        bool=0
    fi
    return $bool
}
function killProcessByMemory() {
    params=($*)
    # 杀死进程的命令
    killCmd=&quot;kill -9&quot;
    # 查询进程号的命令
    memoryInfoCmd=&#x27;ps aux | sort -rn -k +3 | head -${1} | awk &quot;{print $2}&quot;&#x27;
    # echo memoryInfo：$memoryInfo
    needkill=`arr_includes params kill`
    if boolean $needkill; then
        echo &quot;需要删除&quot;
        handledCmd=&quot;${memoryInfoCmd} | ${killCmd}&quot;
    else
        echo &quot;只需要查询&quot;
        handledCmd=$memoryInfoCmd
    fi
    echo &#x27;最终需要的命令为&#x27;
    echo $handledCmd
}
</code></pre><p>当做完这几步初始动作后，我们要实现需求只需要执行下面命令（执行函数）即可</p><pre class="hljs"><code>killProcessByMemory 2 <span class="hljs-comment"># 只需要查询进程号 最终需要的命令为 ps aux | sort -rn -k +3 | head -${1} | awk &quot;{print $2}&quot; </span>
killProcessByMemory 2 <span class="hljs-built_in">kill</span> <span class="hljs-comment"># 需要删除 最终需要的命令为 ps aux | sort -rn -k +3 | head -${1} | awk &quot;{print $2}&quot; | kill -9</span>
</code></pre><p>函数库很多，但最重要的是，我们的初始动作只需要做一遍，一劳永逸！！</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64r4alpmyj20c80cjq3n.jpg" alt=""><figcaption>v2-8a23ef4d6da431c8e231ee43e5db4bf0_b</figcaption></figure><p>其实不只是做一个常用命令的封装，我们还可以做到</p><ul><li>操作系统的初始化：git、nvm、node等等等的安装一键完成、常见软件的自动安装（win、mac也可以！）</li><li>远程服务器配置：远程服务器免密登陆一键完成</li><li>爬虫动作的封装：定时任务不再是执行命令，而是一系列动作的合集</li><li>等等等</li></ul><p>好了，好处显而易见，我们现在对于shell有啥念想？兄弟姐妹们，学它！</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64r4sssjrj204k04k745.jpg" alt=""><figcaption>images (2)</figcaption></figure><h3 id="整体定义">整体定义 <a class="markdownIt-Anchor" href="#整体定义">#</a></h3><p>诱惑了这么久，还是来给个定义吧：shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序；用户可以用Shell来启动、挂起、停止或者编写一些程序；Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强，是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。</p><h3 id="乱入一下案例解释">乱入一下：案例解释 <a class="markdownIt-Anchor" href="#乱入一下案例解释">#</a></h3><p>对于上面【传递进程数n，杀死占用内存排名前n位进程】案例而言</p><pre class="hljs"><code>ps aux|sort -rn -k +3|head -2  | awk '{print $2}' | xargs kill -9
</code></pre><p>ps 命令查找与进程相关的PID号：</p><ul><li>a：显示现行终端机下的所有程序，包括其他用户的程序</li><li>u：以用户为主的格式来显示程序状况</li><li>x：显示所有程序，不以终端机来区分</li></ul><p>sort 对内容根据指定列进行排序</p><ul><li>r：表示是结果倒序排列</li><li>n：以数值大小排序</li><li>-k +3：则是针对第3列的内容进行排序（第三列是 cpu，第四列是内存）</li></ul><p>head 只显示前指定行的数据，获取默认前10行数据</p><p>awk 数据处理神器，这里用于获取第二列（PID，进程id）</p><p>乱入结束，让我们开始叭！</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64r5lryjpj204i03mwec.jpg" alt=""><figcaption>images (3)</figcaption></figure><h1 id="整体目录如何学习一门语言">整体目录：如何学习一门语言 <a class="markdownIt-Anchor" href="#整体目录如何学习一门语言">#</a></h1><p>语言大同小异，核心不过【变量、运算、语句、函数、框架】，shell也是门语言，所以我们也会根据这个脉络进行学习；</p><ul><li>变量：定义、赋值、作用域</li><li>运算：算术运算符， 逻辑运算符</li><li>语句：测试，顺序，分支，循环</li><li>函数：类，接口，包</li><li>框架：系统函数库之上的封装</li><li>特殊点：脚本控制、计划任务、管道、重定向、可视化调试shell脚本（vscode插件 Bash Debug）</li></ul><p>但shell又有所不同，因为它的出现强依赖【unix】，unix的哲学：一条命令只做一件事情；为了组合命令和多次执行，最先是分号;用于同行组合，但不利于展示，于是出现了shell脚本文件，用来保存需要执行的命令，所以有别于其他语言又会出【环境变量、配置文件等等概念】，也强依赖unix的各个命令，这点是需要贯彻整个shell学习脉络的。</p><p>注意：本文不会过多的牵扯linux的知识，awk、xarg、print等等等，小伙伴放心，我们学习最核心的语言逻辑，至于工具，多用即可，放心食用</p><h1 id="shell脚本基础概念">shell脚本基础概念 <a class="markdownIt-Anchor" href="#shell脚本基础概念">#</a></h1><ul><li>什么是shell</li><li>linux的启动过程</li><li>怎么编写一个shell脚本</li><li>shell脚本的执行方式</li><li>内建命令和外部命令的区别</li></ul><h3 id="什么是shell">什么是shell <a class="markdownIt-Anchor" href="#什么是shell">#</a></h3><p>命令解释器，用于解释用户对操作系统的操作，命令解释器有很多种，具体可见：（默认的是bash，其中的a是指again，意思是汇总其他shell解释器的优点，重写实现）</p><pre class="hljs"><code>cat /etc/shells
</code></pre><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5uo8kdeycj20l0070aa9.jpg" alt=""><figcaption>image-20220904165150445</figcaption></figure><h3 id="linux的启动过程">linux的启动过程 <a class="markdownIt-Anchor" href="#linux的启动过程">#</a></h3><p>BIOS - MBR - BootLoader(grub) - kernel - systemd - 系统初始化 - shell</p><pre class="hljs"><code>六步骤
1. BIOS引导，BIOS系统是基本的输入输出系统，功能嵌在主板上，用于选择使用哪个介质（硬盘、光盘、网络）
2. MBR（主引导记录）：用于确定硬盘是否可以被引导
3. BootLoader（grub）：用于启动和引导内核（种类和版本）
4. kernel：
5. systemd：1号进程                                                                                                                                                                                                                                                                                                                                                                                                                                           

</code></pre><h3 id="shell脚本的创建与执行">shell脚本的创建与执行 <a class="markdownIt-Anchor" href="#shell脚本的创建与执行">#</a></h3><h5 id="怎么编写一个shell脚本">怎么编写一个shell脚本 <a class="markdownIt-Anchor" href="#怎么编写一个shell脚本">#</a></h5><p>unix的哲学：一条命令只做一件事情；</p><p>为了组合命令和多次执行，于是出现了shell脚本文件，用来保存需要执行的命令。</p><ol><li>指定解释器：<code>#!/bin/xxx</code>，默认是<code>#!/bin/bash</code>；这其实是后缀，因为在Linux中，文件后缀是没有意义的，所以操作系统要知道这个脚本文件该用什么应用来执行，就需要这个注释来指明，比如node就是<code>#!/usr/bin/node</code></li><li>为文件赋予可执行权限，即<code>chmod u+x [filename]</code></li></ol><h5 id="案例实现sh脚本文件查看var下所有子目录空间">案例：实现sh脚本文件，查看/var下所有子目录空间 <a class="markdownIt-Anchor" href="#案例实现sh脚本文件查看var下所有子目录空间">#</a></h5><ul><li>显示当前目录下的所有子目录所占空间：du -sh *</li></ul><pre class="hljs"><code>cat &gt;&gt; memo.sh &lt;&lt; <span class="hljs-string">EOF
#!/bin/bash
cd /var
du -sh *
EOF</span>
<span class="hljs-comment"># 赋予权限 chmod u+x memo.sh</span>
<span class="hljs-comment"># 执行 ./memo.sh</span>
</code></pre><h5 id="怎么执行一个shell脚本">怎么执行一个shell脚本 <a class="markdownIt-Anchor" href="#怎么执行一个shell脚本">#</a></h5><p>存在四种执行方式</p><ul><li>[解释器] [文件名]：bash ./filename.sh，不需要赋予可执行权限，新创建进程，采用解释器进行执行</li><li>[./文件名]：./filename.sh，新创建进程，需要赋予可执行权限，采用#!指定解释器进行执行</li><li>source [./文件名]: source ./filename.sh，在当前进程进行执行</li><li>.[文件名]：在当前进程进行执行</li></ul><table><thead><tr><th>执行方式</th><th>案例</th><th>是否需要可执行权限</th><th>是否会创建新进程</th><th>补充</th></tr></thead><tbody><tr><td>[解释器] [文件名]</td><td>bash ./filename.sh</td><td>不需要</td><td>会</td><td>内部和当前的终端变量不互通</td></tr><tr><td>[./文件名]</td><td>./filename.sh</td><td>需要</td><td>会</td><td>当使用默认解释器时的缩写</td></tr><tr><td>source [./文件名]</td><td>source ./filename.sh</td><td>不需要</td><td>不会</td><td>内部和当前的终端变量互通</td></tr><tr><td>.[文件名]</td><td>.filename.sh</td><td>不需要</td><td>不会</td><td>其实就是source的缩写</td></tr></tbody></table><ul><li>内建命令不需要创建子进程</li><li>内建命令只对当前shell生效</li></ul><h1 id="shell之变量">shell之变量 <a class="markdownIt-Anchor" href="#shell之变量">#</a></h1><ul><li>增删改查：定义、赋值、引用+查询、删除</li><li>作用范围</li><li>系统环境变量</li><li>环境变量配置文件</li></ul><h2 id="增删改查定义赋值引用删除类型处理">增删改查：定义、赋值、引用、删除、类型处理 <a class="markdownIt-Anchor" href="#增删改查定义赋值引用删除类型处理">#</a></h2><h3 id="定义">定义 <a class="markdownIt-Anchor" href="#定义">#</a></h3><p>即变化的量，字母、数字、下划线的组合，且不能以数字开头（shell变量是弱类型，不区分变量类型）；</p><ul><li><p>变量必须以字母或下划线开头，名字中间只能由字母，数字和下划线组成</p></li><li><p>变量名的长度不得超过255个字符</p></li><li><p>变量名在有效范围内必须唯一</p></li><li><p>变量默认类型都是字符串（存在类型【字符串、整型、浮点型、日期型】）</p><pre class="hljs"><code>$ x=<span class="hljs-number">1</span>
$ y=<span class="hljs-number">2</span>
$ z=<span class="hljs-number">3</span>
$ k=$x+$y+$z
$ echo $k
<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>
</code></pre><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpif9vgevuj30iw07mwfp.jpg" alt=""><figcaption>image-20210413210935114</figcaption></figure><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h654cme8i0j21i60u0ach.jpg" alt=""><figcaption>image-20220913174458417</figcaption></figure></li></ul><h3 id="赋值">赋值 <a class="markdownIt-Anchor" href="#赋值">#</a></h3><p>非交互式赋值存在四种赋值方式</p><ul><li>变量名=变量值（等号左右不能有空格）： a=20</li><li>let进行赋值：let a=20</li><li>将命令赋值给变量：l=ls</li><li>将命令的结果复制给变量（常用）：使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mtext>或者</mtext><mi mathvariant="normal">‘</mi><mi mathvariant="normal">‘</mi><mtext>：</mtext><mi>l</mi><mi>e</mi><mi>t</mi><mi>c</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">()或者``：let c=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord">‘</span><span class="mord">‘</span><span class="mord cjk_fallback">：</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>(ls -l /etc)</li><li>变量间的赋值可以设定默认值：<code>a=${[变量b]-[默认值]}</code>，假设默认值是_，<code>a=${b-_}</code></li></ul><p>注意：变量值如果有空格等特殊字符，可以包含在&quot;&quot;或''中</p><h3 id="引用查询">引用+查询 <a class="markdownIt-Anchor" href="#引用查询">#</a></h3><p>在shell中存在四种引用：单引号、双引号、${}、``</p><ul><li>双引号：部分引用，使用这种引用时，$、`(反引号)、(转义符) 这3个还是会解析成特殊的意义</li><li>单引号：完全引用，只原样输出</li><li>反引号`：命令替换</li></ul><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>变量名即对变量的引用，在部分情况下可以缩写为</mtext></mrow><annotation encoding="application/x-tex">{变量名}即对变量的引用，在部分情况下可以缩写为</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">名</span></span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">缩</span><span class="mord cjk_fallback">写</span><span class="mord cjk_fallback">为</span></span></span></span>变量名（不产生歧义，比如字符串拼接就不能缩写）；</p><p>而查询则可以使用<code>set</code>命令，其会默认查询系统中默认所有已经生效的变量，包括系统变量,也包括自定义变量，结合管道运算符可以精准查询</p><pre class="hljs"><code>set | grep []
</code></pre><p>举例：查询<code>wzy</code>变量的值</p><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpifu24a6mj30mc02w3yw.jpg" alt=""><figcaption>image-20210413212859744</figcaption></figure><h3 id="删除">删除 <a class="markdownIt-Anchor" href="#删除">#</a></h3><p>删除则是<code>unset</code>命令，使用方式如下</p><pre class="hljs"><code>unset [变量名]
</code></pre><h3 id="特殊数据结构之数组">特殊数据结构之数组 <a class="markdownIt-Anchor" href="#特殊数据结构之数组">#</a></h3><ul><li><p>定义：[变量名]=(a b c)</p></li><li><p>显示所有元素：echo ${变量名[@]}</p></li><li><p>显示数组元素个数：echo ${#变量名[@]}</p></li><li><p>显示数组第一个元素：echo ${变量名[0]}（如果直接访问时也会只显示第一个元素 echo $变量名）</p></li></ul><pre class="hljs"><code>colors=( yellow red blue )
echo ${colors[@]}
echo ${#colors[@]}
echo ${colors[0]}
echo $colors
</code></pre><h3 id="类型处理">类型处理 <a class="markdownIt-Anchor" href="#类型处理">#</a></h3><p>shell变量为弱类型并且默认是字符串类型，要想设置变量的类型，可以使用<code>declare</code>命令。</p><p>declare命令用来声明变量类型</p><pre class="hljs"><code>declare [+/-] [选项] 变量名
</code></pre><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">-</td><td style="text-align:left">给变量设定类型属性</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">取消变量的类型属性</td></tr><tr><td style="text-align:left">-a</td><td style="text-align:left">将变量声明为数组类型</td></tr><tr><td style="text-align:left">-i</td><td style="text-align:left">将变量声明为整数型</td></tr><tr><td style="text-align:left">-x</td><td style="text-align:left">将变量声明为环境变量</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:left">将变量声明为只读变量</td></tr><tr><td style="text-align:left">-p</td><td style="text-align:left">显示指定变量的被声明的类型</td></tr></tbody></table><h5 id="设定类型">设定类型 <a class="markdownIt-Anchor" href="#设定类型">#</a></h5><h6 id="整数型">整数型 <a class="markdownIt-Anchor" href="#整数型">#</a></h6><p>举例，将变量设定为整数型从而实现加和，通过配置项<code>-i</code>进行设定</p><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpizsv8r46j30m0092jwq.jpg" alt=""><figcaption>image-20210414085949483</figcaption></figure><h6 id="数组类型">数组类型 <a class="markdownIt-Anchor" href="#数组类型">#</a></h6><p>通过配置项<code>-a</code>进行设定</p><p>定义</p><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpj09yz3xjj30kr02p0v9.jpg" alt=""><figcaption>image-20210414091615602</figcaption></figure><p>取第一个值</p><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpj0acka99j30m401ut9g.jpg" alt=""><figcaption>image-20210414091637595</figcaption></figure><p>取第二个值</p><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpj0ane8qej30kw01wdgn.jpg" alt=""><figcaption>image-20210414091654984</figcaption></figure><p>输出所有</p><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpj0c13pv7j30k60280to.jpg" alt=""><figcaption>image-20210414091814377</figcaption></figure><h5 id="取消变量的类型属性">取消变量的类型属性 <a class="markdownIt-Anchor" href="#取消变量的类型属性">#</a></h5><p>承接上面，此时变量<code>c</code>已经是整型了，我们希望实现取消变量<code>c</code>的类型（即变回字符型），从而实现拼接的效果<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpizvxa490j30li03kdi4.jpg" alt="image-20210414090245877"></p><h5 id="设定为只读变量">设定为只读变量 <a class="markdownIt-Anchor" href="#设定为只读变量">#</a></h5><p>通过配置项<code>-r</code>进行设定</p><pre class="hljs"><code>declare -r [变量名]
</code></pre><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpj04db2gij30n4030tau.jpg" alt=""><figcaption>image-20210414091052571</figcaption></figure><h5 id="查询变量">查询变量 <a class="markdownIt-Anchor" href="#查询变量">#</a></h5><p>此时也可以通过配置项<code>-p</code>查询变量类型</p><pre class="hljs"><code>declare -p [变量名] #显示指定变量的被声明的类型
</code></pre><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpizzamsa0j30n8086dkb.jpg" alt=""><figcaption>image-20210414090600324</figcaption></figure><h5 id="设置为环境变量">设置为环境变量 <a class="markdownIt-Anchor" href="#设置为环境变量">#</a></h5><p>通过配置项<code>-x</code>设置变量为环境变量</p><pre class="hljs"><code>declare -x [变量名]
</code></pre><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpj01k3dxdj30na02ymz2.jpg" alt=""><figcaption>image-20210414090810696</figcaption></figure><p>由此也可以看到，之前定义全局环境变量的方式<code>export [变量名]</code>其实就是<code>declare -x [变量名]</code>的语法糖</p><h2 id="变量的作用范围">变量的作用范围 <a class="markdownIt-Anchor" href="#变量的作用范围">#</a></h2><ol><li><p>默认范围：只针对当前的终端（shell）生效</p></li><li><p>支持子进程访问父进程的变量：<code>export [变量名]=[变量值]</code>；（取消变量可以使用<code>unset [变量名]</code>）</p></li><li><p>系统环境变量：每个shell打开都能获取到的变量</p></li></ol><p>其中第一条可以使用<code>bash</code>命令创建一个新的shell进行测试；第二条就是export和unset关键字；关键是系统环境变量，重点分析：</p><h3 id="系统环境变量">系统环境变量 <a class="markdownIt-Anchor" href="#系统环境变量">#</a></h3><p>环境变量主要根据两个角度进行划分：用户级别是属于系统还是属于用户；shell级别是属于当前的shell还是所有shell。而这些是通过配置文件进行区分和记录的，不同作用范围和功能的变量分属不同的配置文件中，主要有四个文件<code>/etc/profile</code>、<code>~/.bash_profile</code>、<code>~/.bashrc</code>、<code>/etc/bashrc</code>。系统环境变量的查询：env和set</p><h5 id="常见变量">常见变量 <a class="markdownIt-Anchor" href="#常见变量">#</a></h5><table><thead><tr><th>变量名</th><th>含义</th><th>常见操作</th><th>注意</th></tr></thead><tbody><tr><td>$PATH</td><td>搜索路径；当执行全局命令（即直接执行命令名）时，会在PATH值内所有路径进行查找并执行</td><td>PATH=$PATH:[新增的全局路径]</td><td>当前定义的变量，只会会当前终端和其子shell生效（因为所有的环境变量都被export导出过了）</td></tr><tr><td>$PS1</td><td>当前提示的终端信息</td><td>添加完整路径信息、时间等等信息</td><td></td></tr><tr><td>$?</td><td>上条命令是否正确执行</td><td>0（正确） | 1（错误，非0值）</td><td>预定义变量</td></tr><tr><td>$$</td><td>当前进程的PID</td><td></td><td>预定义变量</td></tr><tr><td>$0</td><td>当前进程（或执行文件）的名称</td><td></td><td>预定义变量；bash xx.sh时是bash；.xx.sh时是xx.sh</td></tr><tr><td>$#</td><td>传递到脚本的参数的个数</td><td></td><td></td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数</td><td></td><td></td></tr><tr><td>$1-9（10之后要用{}包裹）</td><td>用于获取命令执行参数</td><td></td><td>位置变量</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="环境变量配置文件">环境变量配置文件 <a class="markdownIt-Anchor" href="#环境变量配置文件">#</a></h3><ul><li>/etc/profile：</li><li>/etc/profile.d：目录</li><li>~/.bash_profile</li><li>~/.bashrc</li><li>/etc/bashrc</li></ul><p>需要注意的是</p><ul><li>etc下的是所有用户通用，而~则是用户用户家目录，只对指定用户生效；</li><li>profile文件和bashrc文件的加载取决于shell的种类是loginShell还是noLoginShell（在登陆时采用的是<code>su - [用户名]</code>，这时如果有这个-号就是loginShell，不加则是noLoginShell）<ul><li>noLoginShell只会加载执行bashrc</li><li>loginShell则会全部加载执行</li></ul></li></ul><p>加载顺序为</p><pre class="hljs"><code>/etc/profile - ~/.bash_profile - ~/.bashrc - /etc/bashrc
</code></pre><p>如果修改了配置文件，是不会立即重新加载的，需要我们重启终端或者执行source命令</p><pre class="hljs"><code>source [修改的配置文件地址]
</code></pre><p>在操作系统加载过程中，主要按如下顺序进行加载</p><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpj1kslny9j30p606tdfz.jpg" alt=""><figcaption>f49353175c1062b807c03b03bd9b5817</figcaption></figure><p>而作用范围如下图</p><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpj18uxeecj30s70e8jst.jpg" alt=""><figcaption>image-20210414094947465</figcaption></figure><h1 id="shell之运算">shell之运算 <a class="markdownIt-Anchor" href="#shell之运算">#</a></h1><ul><li>赋值运算符：用于字符串赋值，赋值使用=，取消赋值使用unset（想到于js中的delete）</li><li>算数运算符：用于算数赋值，+-*/**%，使用方式如下<ul><li>使用expr声明，如 a=`expr 4 + 5`（不支持浮点数）</li></ul></li><li>数字常量：比expr精简，可以使用let进行赋值操作，如 let a=1+2；</li><li>双圆括号：是let的缩写，如((a=10))、((a++))</li></ul><p>其实expr、let或者(())都是为了向shell声明，我目前在做算数赋值的动作，这也就能理解为什么要把整个式子都放在双圆括号中了。</p><h1 id="shell之特殊符号">shell之特殊符号 <a class="markdownIt-Anchor" href="#shell之特殊符号">#</a></h1><h3 id="引号">引号 <a class="markdownIt-Anchor" href="#引号">#</a></h3><ul><li>双引号：部分引用，使用这种引用时，$、`(反引号)、(转义符) 这3个还是会解析成特殊的意义</li><li>单引号：完全引用，只原样输出</li><li>反引号：执行命令</li></ul><h3 id="括号">括号 <a class="markdownIt-Anchor" href="#括号">#</a></h3><ul><li>圆括号<ul><li>()：单独使用圆括号会产生一个子shell（这样执行的表达式的输出就不会在当前shell中显示），也可用于数组赋值（colors=(yellow red blue)）</li><li>(())：算数运算赋值，是let的缩写</li><li>$()：将命令赋值给变量</li></ul></li><li>方括号<ul><li>[]：单独使用是测试或数组元素功能</li><li>[[]]：表示测试表达式</li></ul></li></ul><pre class="hljs"><code>[ 5 -gt 4 ] # 5是否大于4 
[[ 5 -gt 4 ]] # 5是否大于4 
echo $? # 测试上条命令执行结果
</code></pre><ul><li>尖括号&lt;&gt;：重定向符号</li><li>花括号{}：<ul><li>输出范围：echo {0..9}</li><li>文件复制</li></ul></li></ul><pre class="hljs"><code><span class="hljs-meta">#</span><span class="bash"> 下面两条命令等价</span>
cp /etc/passwd{,.bak} 
cp /etc/passwd /etc/passwd.bak
</code></pre><h3 id="运算符号和逻辑符号">运算符号和逻辑符号 <a class="markdownIt-Anchor" href="#运算符号和逻辑符号">#</a></h3><ul><li>算数运算符：+-*/ %</li><li>比较运算符：&gt;&lt;=</li><li>逻辑运算符：&amp;&amp;||!</li></ul><pre class="hljs"><code>(( 5 &gt; 4 ))
echo $?
(( 5 &gt; 4 &amp;&amp; 6 &lt; 5))
echo $?
(( 5 &gt; 4 || 6 &lt; 5))
echo $?
(( ! 5 &gt; 4 ))
echo $?
</code></pre><h3 id="转义符号">转义符号 <a class="markdownIt-Anchor" href="#转义符号">#</a></h3><ul><li>\转义某字符<ul><li>普通字符转义后有不同的功能，如\n</li><li>特殊字符转义后消除了特殊功能，如<code>\’</code></li></ul></li></ul><h3 id="其他特殊字符">其他特殊字符 <a class="markdownIt-Anchor" href="#其他特殊字符">#</a></h3><table><thead><tr><th>字符</th><th>含义</th><th>补充</th></tr></thead><tbody><tr><td>#</td><td>注释</td><td></td></tr><tr><td>;</td><td>命令分隔符</td><td>case语句的分隔符要转义 ;;</td></tr><tr><td>:</td><td>空指令</td><td>返回值永远是真</td></tr><tr><td>.</td><td>和source命令相同</td><td>. sh文件名</td></tr><tr><td>~</td><td>家目录</td><td>cd ~回到家目录；cd -/+ 回到上/下一个目录；</td></tr><tr><td>,</td><td>分隔目录</td><td></td></tr><tr><td>*</td><td>通配符</td><td></td></tr><tr><td>?</td><td>条件测试 或 通配符</td><td>ls ?.sh 查询文件名为单个字或没有字的sh文件</td></tr><tr><td>$</td><td>取值符号</td><td></td></tr><tr><td>|</td><td>管道符</td><td></td></tr><tr><td>&amp;</td><td>后台运行</td><td></td></tr><tr><td>_</td><td>空格</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><pre class="hljs"><code># if
if [ &quot;$PS1&quot; ]; then

enif
# case
case $TERM in 
  xterm*|vte*)
  	语句1
  ;;
  screen*)
  	语句2
  ;;
  *)
  	语句3
  ;;
esac
</code></pre><h3 id="运算的优先级">运算的优先级 <a class="markdownIt-Anchor" href="#运算的优先级">#</a></h3><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpj0njlc01j31o00qetm3.jpg" alt=""><figcaption>priority</figcaption></figure><h2 id="尾声">尾声 <a class="markdownIt-Anchor" href="#尾声">#</a></h2><p>至此，我们的shell训练营首篇就结束啦。</p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../shell编程训练营/index.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../shell编程训练营/2. Shell 中的数组应用、参数处理和函数的应用.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.24</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../shell编程训练营/index.html">shell编程训练营</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item chapter-item-current"><a href="../shell编程训练营/1. Shell 的基本介绍、常用命令以及 Shell 的流程控制.html">我们为什么要学习shell</a></li><li class="chapter-item"><a href="../shell编程训练营/2. Shell 中的数组应用、参数处理和函数的应用.html">shell之语句</a></li><li class="chapter-item"><a href="../shell编程训练营/3. Shell 的函数、模块化、公共函数库.html">shell之函数</a></li><li class="chapter-item"><a href="../shell编程训练营/4. Shell周边：语言特殊点调试 Debug 方案vscode对shell的支持.html">语言特殊点</a></li><li class="chapter-item"><a href="../shell编程训练营/开营前置信息.html">开营前置信息.md</a></li></ul><li class="chapter-item"><a href="../vscode训练营/index.html">vscode训练营</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../vscode训练营/day1：简单了解插件开发.html">day1：简单了解插件开发.md</a></li><li class="chapter-item"><a href="../vscode训练营/day2：实现一个简单代码工具.html">day2：实现一个简单代码工具.md</a></li><li class="chapter-item"><a href="../vscode训练营/day3：vscode配置文件.html">day3：vscode配置文件.md</a></li><li class="chapter-item"><a href="../vscode训练营/day4：完善工具，添加更多功能并发布.html">然后输入之前获取到的 token</a></li><li class="chapter-item"><a href="../vscode训练营/开营计划.html">开营计划.md</a></li></ul><li class="chapter-item"><a href="../webpack插件训练营/index.html">webpack插件训练营</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../webpack插件训练营/day1. 简单了解webpack.html">day1. 简单了解webpack.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day2. webpack配置文件拆分及开发环境搭建.html">day2. webpack配置文件拆分及开发环境搭建.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day3. 文件类型处理篇.html">day3. 文件类型处理篇.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day4. 性能分析篇.html">day4. 性能分析篇.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day5. 性能优化篇：体积优化.html">day5. 性能优化篇：体积优化.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day6. 性能优化篇：缓存.html">day6. 性能优化篇：缓存.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day7. webpack 核心工作流程.html">day7. webpack 核心工作流程.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day8. 熟悉插件和loader的发布流程.html">day8. 熟悉插件和loader的发布流程.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/开营计划.html">开营计划.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/提效技巧篇：px转rem.html">提效技巧篇：px转rem.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/提效技巧篇：基于glob实现自动化路由的MPA.html">提效技巧篇：基于glob实现自动化路由的MPA.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/提效技巧篇：浏览器前缀自动添加.html">提效技巧篇：浏览器前缀自动添加.md</a></li></ul><li class="chapter-item"><a href="../前端爬虫/index.html">前端爬虫</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../前端爬虫/1. 了解爬虫 - puppetter实战.html">1. 了解爬虫 - puppetter实战.md</a></li><li class="chapter-item"><a href="../前端爬虫/2. 数据入库.html">2. 数据入库.md</a></li><li class="chapter-item"><a href="../前端爬虫/3. 展示应用实现.html">3. 展示应用实现.md</a></li><li class="chapter-item"><a href="../前端爬虫/4. 实战：kkb一键爬取所有vip课程.html">4. 实战：kkb一键爬取所有vip课程.md</a></li><li class="chapter-item"><a href="../前端爬虫/开营计划.html">开营计划.md</a></li></ul></ul><li class="chapter-item"><a href="../学习小组规划.html">学习小组规划.md</a></li><li class="chapter-item"><a href="../开营计划.html">开营计划.md</a></li><li class="chapter-item"><a href="../模板.html">模板.md</a></li><li class="chapter-item"><a href="../谷歌浏览器插件/index.html">谷歌浏览器插件</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../谷歌浏览器插件/开营计划.html">开营计划.md</a></li></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"shell编程训练营/1. Shell 的基本介绍、常用命令以及 Shell 的流程控制.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li>\n<ul>\n<li><a href="#%E6%95%B4%E4%BD%93%E5%AE%9A%E4%B9%89">整体定义</a></li>\n<li><a href="#%E4%B9%B1%E5%85%A5%E4%B8%80%E4%B8%8B%E6%A1%88%E4%BE%8B%E8%A7%A3%E9%87%8A">乱入一下：案例解释</a></li>\n<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFshell">什么是shell</a></li>\n<li><a href="#linux%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">linux的启动过程</a></li>\n<li><a href="#shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%89%A7%E8%A1%8C">shell脚本的创建与执行</a></li>\n</ul>\n</li>\n<li><a href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9A%E4%B9%89%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8%E5%88%A0%E9%99%A4%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86">增删改查：定义、赋值、引用、删除、类型处理</a>\n<ul>\n<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>\n<li><a href="#%E8%B5%8B%E5%80%BC">赋值</a></li>\n<li><a href="#%E5%BC%95%E7%94%A8%E6%9F%A5%E8%AF%A2">引用+查询</a></li>\n<li><a href="#%E5%88%A0%E9%99%A4">删除</a></li>\n<li><a href="#%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84">特殊数据结构之数组</a></li>\n<li><a href="#%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86">类型处理</a></li>\n</ul>\n</li>\n<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4">变量的作用范围</a>\n<ul>\n<li><a href="#%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">系统环境变量</a></li>\n<li><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">环境变量配置文件</a></li>\n<li><a href="#%E5%BC%95%E5%8F%B7">引号</a></li>\n<li><a href="#%E6%8B%AC%E5%8F%B7">括号</a></li>\n<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7%E5%92%8C%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7">运算符号和逻辑符号</a></li>\n<li><a href="#%E8%BD%AC%E4%B9%89%E7%AC%A6%E5%8F%B7">转义符号</a></li>\n<li><a href="#%E5%85%B6%E4%BB%96%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">其他特殊字符</a></li>\n<li><a href="#%E8%BF%90%E7%AE%97%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">运算的优先级</a></li>\n</ul>\n</li>\n<li><a href="#%E5%B0%BE%E5%A3%B0">尾声</a></li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>