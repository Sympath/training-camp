<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>语言特殊点 - Documents</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">Documents</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../shell编程训练营/index.html" class="breadcrumb-item">shell编程训练营</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../shell编程训练营/4. Shell周边：语言特殊点调试 Debug 方案vscode对shell的支持.html" class="breadcrumb-item">语言特殊点</a></div><h1 class="article-title">语言特殊点</h1><div class="article"><p>一门语言的出现必然存在其特殊点，java的jvm和面向对象、js的解释型、python的自动化等等，shell也不例外</p><ul><li>脚本控制：优先级控制、捕获信号</li><li>计划任务：定时执行任务</li><li>延时计划任务：anacontab</li><li>计算任务加锁：flock</li></ul><h2 id="脚本控制">脚本控制 <a class="markdownIt-Anchor" href="#脚本控制">#</a></h2><p>cpu和资源的分配</p><ul><li>nice和renice调整优先级</li><li>死循环的控制：cpu占用和死机</li></ul><p>当执行如下命令时，系统会进入假死状态</p><pre class="hljs"><code>.()^C|.&amp;}.
</code></pre><h3 id="捕获信号">捕获信号 <a class="markdownIt-Anchor" href="#捕获信号">#</a></h3><p>捕获语句语法如下</p><pre class="hljs"><code>trap &quot;[行为]&quot; [信号编号]
</code></pre><ul><li>kill 默认会发送15号信号给应用程序</li><li>ctrl + c发送2号信息给应用程序</li><li>-9号信号不可阻塞</li></ul><h5 id="案例一监听15号信号">案例一：监听15号信号 <a class="markdownIt-Anchor" href="#案例一监听15号信号">#</a></h5><p>循环监听15信号，当此信号被下发时，打印<code>sig 15</code>；</p><pre class="hljs"><code><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>
trap &quot;echo sig 15&quot; 15
echo $$ # 打印端口
while :; do
    :
done
</code></pre><p>启动之后会首先打印端口口，然后我们执行如下命令像指定进程发送15信号</p><pre class="hljs"><code>kill -15 [pid]
</code></pre><h5 id="案例二监听2号信号">案例二：监听2号信号 <a class="markdownIt-Anchor" href="#案例二监听2号信号">#</a></h5><p>循环监听15信号，当此信号被下发时，打印<code>sig 15</code>；</p><pre class="hljs"><code><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>
trap &quot;echo sig 2&quot; 2
echo $$ # 打印端口
while :; do
    :
done
</code></pre><p>启动之后我们<code>ctrl+c</code>实现触发</p><h2 id="计划任务">计划任务 <a class="markdownIt-Anchor" href="#计划任务">#</a></h2><ul><li>一次性计划任务：at</li><li>周期性计划任务：cron</li><li>延时计划任务：anacrontab</li><li>计划任务加锁 flock</li></ul><p>注意事项：</p><ol><li>定时任务是没有终端的，这也就意味这默认没有输出，如果需要查看输出结果就需要用到重定向符号<code>&gt;</code></li></ol><h3 id="一次性计划任务">一次性计划任务 <a class="markdownIt-Anchor" href="#一次性计划任务">#</a></h3><pre class="hljs"><code>at [选项] [时间]
</code></pre><ul><li><p>录入命令：回车后就会出现<code>at&gt;</code>这种要求输入命令的提示，输入需要在指定时间输入命令</p></li><li><p>完成记录：输入完成后按下ctrl + D即完成了命令的存入</p></li><li><p>查看记录：可以使用命令<code>atq</code>查看当前一次性任务列表</p></li><li><p>删除记录：可以使用<code>atrm + [编号]</code>进行删除</p></li></ul><h5 id="注意事项">注意事项 <a class="markdownIt-Anchor" href="#注意事项">#</a></h5><ol><li>at 命令是一次性定时计划任务，<code>at</code> 的守护进程 <code>atd</code> 会以后台模式运行，检查作业队列来运行。</li><li>默认情况下，<code>atd</code> 守护进程每 <code>60</code> 秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。</li><li><code>at</code> 命令是一次性定时计划任务，执行完一个任务后不再执行此任务了</li><li>在使用 <code>at</code> 命令的时候，一定要保证 <code>atd</code> 进程的启动 , 可以使用相关指令来查看</li></ol><pre class="hljs"><code>ps -ef | grep atd //可以检测 atd 是否在运行
</code></pre><p>画一个示意图<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h604lw98z5j20j408t3ys.jpg" alt="在这里插入图片描述"></p><h5 id="选项">选项 <a class="markdownIt-Anchor" href="#选项">#</a></h5><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h604moyirtj20pb09ymy7.jpg" alt=""><figcaption>在这里插入图片描述</figcaption></figure><h5 id="时间定义">时间定义 <a class="markdownIt-Anchor" href="#时间定义">#</a></h5><table><thead><tr><th>支持格式</th><th>案例</th><th>补充</th></tr></thead><tbody><tr><td>接受在当天的 hh:mm（小时:分钟）式的时间指定；假如该时间已过去，那么就放在第二天执行</td><td>04:00</td><td></td></tr><tr><td>接受比较模糊的词语来指定时间</td><td></td><td>midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午 4 点）等</td></tr><tr><td>采用 12 小时计时制，即在时间后面加上 AM（上午）或 PM（下午）来说明是上午还是下午</td><td>12pm</td><td></td></tr><tr><td>指定命令执行的具体日期，指定格式为 month day（月 日）或 mm/dd/yy（月/日/年）或 dd.mm.yy（日.月.年）</td><td>04:00 2021-05-12</td><td>指定的日期必须跟在指定时间的后面</td></tr><tr><td>使用相对计时法。指定格式为：now + count time-units</td><td>now + 5 minutes</td><td>now 就是当前时间，time-units 是时间单位，这里能够是 minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count 是时间的数量，几天，几小时</td></tr><tr><td>直接使用 today（今天）、tomorrow（明天）来指定完成命令的时间。</td><td></td><td></td></tr></tbody></table><h5 id="案例">案例 <a class="markdownIt-Anchor" href="#案例">#</a></h5><p>1分钟后将在/tmp目录下创建<code>hello.txt</code>并写入内容<code>hello</code></p><pre class="hljs"><code>at now + 1 minutes
# at&gt;内容框出现后输入如下内容，然后按ctrl + D
echo hello &gt; /tmp/hello.txt
# 验证
cat /tmp/hello.txt
</code></pre><h3 id="周期性计划任务cron">周期性计划任务：cron <a class="markdownIt-Anchor" href="#周期性计划任务cron">#</a></h3><pre class="hljs"><code>crontab [选项]
</code></pre><p>crontab是根据选项执行对应行为的</p><ul><li>录入命令：crontab -e ，回车后打开一个vim的编辑界面，输入格式为【分钟 小时 日期 月份 星期 执行的命令】，*代表所有，比如小时位是*，代表每小时；比如<code>* * * * * /usr/bin/date &gt;&gt; /tmp/deepinout.com.txt</code></li><li>查看计划执行记录：可以执行<code>tail -f /var/log/cron</code>查看定时任务执行记录</li><li>查看用户的计划：<code>crontab -l</code>，其实就等同于<code>cat /var/spool/cron/和用户同名的文件</code>，只是做了个文件读取到标准输出上操作而已</li><li>删除记录：可以使用<code>crontab -r [编号]</code>进行删除</li></ul><h5 id="注意事项-1">注意事项 <a class="markdownIt-Anchor" href="#注意事项-1">#</a></h5><ol><li>最小的设置时间单位是分钟（可以用第三方软件包实现秒）</li><li>注意命令的路径问题</li></ol><p>每个用户都有自己的周期性计划任务配置文件，保存在/var/spool/cron/下面，以用户名作为文件名。</p><h3 id="crontab示例">crontab示例 <a class="markdownIt-Anchor" href="#crontab示例">#</a></h3><p>每分钟将日期保存在指定文件中</p><pre class="hljs"><code>* * * * * /usr/bin/date &gt;&gt; /tmp/deepinout.com.txt
</code></pre><h5 id="固定星期几执行计划任务">固定星期几执行计划任务 <a class="markdownIt-Anchor" href="#固定星期几执行计划任务">#</a></h5><p>周一每分钟执行</p><pre class="hljs"><code>* * * * 1 /usr/bin/date &gt;&gt; /tmp/deepinout.com.txt
</code></pre><p>周五每分钟执行</p><pre class="hljs"><code>* * * * 5 /usr/bin/date &gt;&gt; /tmp/deepinout.com.txt
</code></pre><p>周一和周五每分钟执行</p><pre class="hljs"><code>* * * * 1,5 /usr/bin/date &gt;&gt; /tmp/deepinout.com.txt
</code></pre><p>周一至周五每分钟执行</p><pre class="hljs"><code>* * * * 1-5 /usr/bin/date &gt;&gt; /tmp/deepinout.com.txt
</code></pre><h5 id="同时满足指定日期和星期才执行任务">同时满足指定日期和星期才执行任务 <a class="markdownIt-Anchor" href="#同时满足指定日期和星期才执行任务">#</a></h5><p>7月8日且是周一至周五，每分钟执行</p><pre class="hljs"><code>* * 8 7 1-5 /usr/bin/date &gt;&gt; /tmp/deepinout.com.txt
</code></pre><h3 id="延时计划任务anacontab">延时计划任务：anacontab <a class="markdownIt-Anchor" href="#延时计划任务anacontab">#</a></h3><p>为了缓解cron中一瞬间大量任务并发执行而导致系统压力过大的问题。相关文件</p><ul><li>/etc/cron.d/0hourly：存储着运行任务的信息</li><li>/etc/anacontab：</li></ul><pre class="hljs"><code># /etc/anacrontab: configuration file for anacron

# See anacron(8) and anacrontab(5) for details.

SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
# the maximal random delay added to the base delay of the jobs
RANDOM_DELAY=45
# the jobs will be started during the following hours only
START_HOURS_RANGE=3-22

#period in days   delay in minutes   job-identifier   command
1       5       cron.daily              nice run-parts /etc/cron.daily
7       25      cron.weekly             nice run-parts /etc/cron.weekly
@monthly 45     cron.monthly            nice run-parts /etc/cron.monthly
</code></pre><h5 id="环境变量部分">环境变量部分 <a class="markdownIt-Anchor" href="#环境变量部分">#</a></h5><ul><li><p>RANDOME_DELAY=45：表示anacron在执行任务前先延时一段随记的时间再执行，这段随机的时间为0-45分钟之内的随机数。</p></li><li><p>START_HOURS_RANGE=3-22：指定了只有在凌晨3点到晚上22点这个时间段内才允许执行任务。</p></li></ul><h5 id="执行计划部分">执行计划部分 <a class="markdownIt-Anchor" href="#执行计划部分">#</a></h5><p>由四部分组成：</p><ul><li>period in days：轮回天数，表示任务多少天执行一次。</li><li>delay in minutes：表示启动Anacron和运行作业时间之间的延迟，单位为分钟. 当然前提是自最后一次运行之后所经过的时间超出了轮回天数。 但是它并不是作业真正运行的时间，真正运行的时间还需要加上RANDOME_DELAY中设置的随机分钟数。</li><li>job-identifier：作业的标识符。anacron在执行任务时会将日期写入 <code>/var/spool/anacron/$job-identifier</code> 文件中</li><li>command：实际运行的命令。这里的 <code>run-parts</code> 是一个运行指定目录中所有程序与脚本的命令，可以通过 <code>man run-parts</code> 来查看它的说明</li></ul><h5 id="特点如下">特点如下 <a class="markdownIt-Anchor" href="#特点如下">#</a></h5><ul><li>anacron 只运行每天/周/月的任务</li><li>如果一项任务在预定的时间机器处于关机状态，那么在下次开机的时候会执行；</li><li>anacron 自己没有守护进程运行，需要依赖于外部工具（例如 crond）；</li><li>可以设置一个延时时间，当到指定时间时，等待一个延时时间再执行任务；</li></ul><h3 id="计划任务加锁flock">计划任务加锁：flock <a class="markdownIt-Anchor" href="#计划任务加锁flock">#</a></h3><h5 id="为什么出现">为什么出现 <a class="markdownIt-Anchor" href="#为什么出现">#</a></h5><p>在使用crontab管理定时脚本时，如果设定的脚本执行时间间隔较短，例如5分钟执行一次，正常情况下，脚本执行耗时1分钟，在非正常情况下（如服务器压力较大的情况下，或数据量突然增大），脚本执行时间超过5分钟，这时就会造成多个脚本同时执行，严重时甚至拖垮服务器，影响服务器上的其它服务。</p><p>当多个进程可能会执行同一个脚本，这些进程需要保证其它进程没有在操作，以免重复执行，这就是flock的作用。</p><h5 id="怎么做到的">怎么做到的 <a class="markdownIt-Anchor" href="#怎么做到的">#</a></h5><p>通常，这样的进程会使用一个锁文件，也就是建立一个文件来告诉别的进程自己在运行，如果检测到那个文件存在则认为有操作同样数据的进程在工作。</p><h5 id="如何使用">如何使用 <a class="markdownIt-Anchor" href="#如何使用">#</a></h5><pre class="hljs"><code>flock -h

Usage:
 flock [options] &lt;file|directory&gt; &lt;command&gt; [command args]
 flock [options] &lt;file|directory&gt; -c &lt;command&gt;
 flock [options] &lt;file descriptor number&gt;

Options:
-s, --shared:    获得一个共享锁
-x, --exclusive: 获得一个独占锁
-u, --unlock:    移除一个锁，通常是不需要的，脚本执行完会自动丢弃锁
-n, --nonblock:  如果没有立即获得锁，直接失败而不是等待
-w, --timeout:   如果没有立即获得锁，等待指定时间
-o, --close:     在运行命令前关闭文件的描述符号。用于如果命令产生子进程时会不受锁的管控
-c, --command:   在shell中运行一个单独的命令
-h, --help       显示帮助
-V, --version:   显示版本
</code></pre><h5 id="使用案例">使用案例 <a class="markdownIt-Anchor" href="#使用案例">#</a></h5><pre class="hljs"><code>flock -xn &quot;/tmp/f.lock&quot; -c &quot;/root/a.sh&quot;
</code></pre><p>下图是两个终端同时运行这条命令，后执行者会因为抢不到锁而得不到执行，马上退出</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h60he0uvylj20vv09z0u6.jpg" alt=""><figcaption>flock为脚本加锁</figcaption></figure><h2 id="重点概念管道">重点概念：管道 <a class="markdownIt-Anchor" href="#重点概念管道">#</a></h2><p>当我们单纯的运行多个程序而不需要它们彼此间有互通时，存在如下方式</p><table><thead><tr><th style="text-align:left">多命令执行符</th><th style="text-align:left">格式</th><th style="text-align:left">作用</th><th style="text-align:left">案例</th></tr></thead><tbody><tr><td style="text-align:left">;</td><td style="text-align:left">命令1;命令2</td><td style="text-align:left">多个命令执行，命令之间没有任何逻辑联系</td><td style="text-align:left">echo 1;echo 2;</td></tr><tr><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">命令1&amp;&amp;命令2</td><td style="text-align:left">逻辑与 当命令1正确执行，则命令2才会执行 当命令1执行不正确，则命令2不会执行</td><td style="text-align:left">echo 1&amp;&amp;echo 2;</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">命令1\ 命令2</td><td style="text-align:left">逻辑或 当命令1执行不正确，则命令2才会执行 当命令1正确执行，则命令2不会执行</td><td style="text-align:left">echo 1\echo 2;</td></tr></tbody></table><pre class="hljs"><code><span class="hljs-built_in">echo</span> 1;<span class="hljs-built_in">echo</span> 2;
<span class="hljs-built_in">echo</span> 1&amp;&amp;<span class="hljs-built_in">echo</span> 2;
<span class="hljs-built_in">echo</span> 1||<span class="hljs-built_in">echo</span> 2;
</code></pre><p>而如果需要互通，比如第一个命令的返回传递给第二个命令，就需要用到管道了，管道的本质就是将多个程序进行了一个连接，和信号一样，也是进程通信的方式之一</p><ul><li>管道与管道符（即匿名管道，|，作用是将前一个命令的结果传递给后面的命令，如<code>ls -l | more</code>）</li><li>子进程与子shell</li></ul><pre class="hljs"><code>ls /etc/ | more
netstat -an | grep ESTABLISHED | wc -l
</code></pre><p>注意：因为管道是以子进程方式进行执行的，所以内建命令的执行不会传递给父进程。</p><h2 id="重点概念重定向">重点概念：重定向 <a class="markdownIt-Anchor" href="#重点概念重定向">#</a></h2><p>重定向的本质就是将文件和输入、输出（包含标准输出、错误输出）进行了一个连接</p><ul><li>输入重定向符号：&lt;</li><li>输出重定向符号：<ul><li>&gt;：覆盖写入文件</li><li>&gt;&gt;：追加写入文件</li><li>2&gt;：错误输出写入文件</li><li>&amp;&gt;：正确和错误输出统一写入到文件中</li></ul></li></ul><p>多行内容写入</p><pre class="hljs"><code>cat &gt; [文件名] &lt;&lt; EOF
xxxx内容
EOF
</code></pre><h3 id="具体整理">具体整理 <a class="markdownIt-Anchor" href="#具体整理">#</a></h3><table><thead><tr><th style="text-align:left">设备</th><th style="text-align:left">设备文件名</th><th style="text-align:left">文件描述符</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:left">键盘</td><td style="text-align:left">/dev/stdin</td><td style="text-align:left">0</td><td style="text-align:left">标准输入</td></tr><tr><td style="text-align:left">显示器</td><td style="text-align:left">/dev/stdout</td><td style="text-align:left">1</td><td style="text-align:left">标准输出</td></tr><tr><td style="text-align:left">显示器</td><td style="text-align:left">/dev/stderr</td><td style="text-align:left">2</td><td style="text-align:left">标准错误输出</td></tr></tbody></table><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">符号</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">标准输出重定向</td><td style="text-align:left">命令 &gt; 文件</td><td style="text-align:left">以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中</td></tr><tr><td style="text-align:left">标准输出重定向</td><td style="text-align:left">命令 &gt;&gt; 文件</td><td style="text-align:left">以追加的方式，把命令的正确输出输出到指定的文件或设备当中</td></tr><tr><td style="text-align:left">错误输出重定向</td><td style="text-align:left">命令 2&gt;文件</td><td style="text-align:left">以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中</td></tr><tr><td style="text-align:left">错误输出重定向</td><td style="text-align:left">命令 2&gt;&gt;文件</td><td style="text-align:left">以追加的方式，把命令的错误输出输出到指定的文件或设备当中</td></tr><tr><td style="text-align:left">正确输出和错误输出同时保存</td><td style="text-align:left">命令&gt;文件 2&gt;&amp;1</td><td style="text-align:left">以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td style="text-align:left">正确输出和错误输出同时保存</td><td style="text-align:left">命令&gt;文件 2&gt;&gt;&amp;1</td><td style="text-align:left">以追加的方式，把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td style="text-align:left">正确输出和错误输出同时保存</td><td style="text-align:left">命令&amp;&gt;文件（类似2&gt;&amp;1）</td><td style="text-align:left">以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td style="text-align:left">正确输出和错误输出同时保存</td><td style="text-align:left">命令&amp;&gt;&gt;文件</td><td style="text-align:left">以追加的方式，把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td style="text-align:left">正确输出和错误输出同时保存</td><td style="text-align:left">命令&gt;&gt;文件1 2&gt;文件2</td><td style="text-align:left">以覆盖的方式，正确的输出追加到文件1中，把错误输出追加到文件2中</td></tr></tbody></table><h3 id="案例-1">案例 <a class="markdownIt-Anchor" href="#案例-1">#</a></h3><pre class="hljs"><code><span class="hljs-meta">#</span><span class="bash"> 创建a.txt并写入123</span>
echo &#x27;123&#x27; &gt; a.txt
<span class="hljs-meta">#</span><span class="bash"> 将文件内容输入进变量</span>
read a &lt; a.txt
<span class="hljs-meta">#</span><span class="bash"> 将a变量内容追加入a.txt</span>
echo $a &gt;&gt; a.txt
<span class="hljs-meta">#</span><span class="bash"> 将命令执行错误的提示内容写入error.log中</span>
nocmd 2&gt; error.log
</code></pre><h1 id="shell之调试">shell之调试 <a class="markdownIt-Anchor" href="#shell之调试">#</a></h1><p>说了这么多，最后还是要落到写的程度来，【纸上得来终觉浅，绝知此事要躬行】，写自然免不了有问题，当有问题的时候我们就需要一些手段去调试我们的代码了。怎么调呢？对我个人而言经历了三个阶段</p><ul><li>log时期：变量使用echo输出，个人通过vscode插件优化至一键生成日志语句</li><li>自动输出时期：<code>set</code>命令用来修改 Shell 环境的运行参数，也就是可以定制环境，这里就可以做到自动输出日志</li><li>运行时处理时期：也就是我们常说的debugger了，没错，我们可以和debugger js一样去可视化处理shell脚本（cool~）；个人通过vscode插件优化至一键完成搭建动作【如需试用可以搜索：weiyi-tools】</li></ul><p>逐一分享啦</p><h3 id="log时期">log时期 <a class="markdownIt-Anchor" href="#log时期">#</a></h3><p>这个很简单，唯一要注意的就是shell变量类型导致的奇葩输出，在shell中默认变量是字符串类型，而其他类型的输出则有不同</p><ul><li>string：echo $变量名</li><li>array：echo ${变量名[@]} ，日后直接echo $变量名会只打印第一个字符</li><li>function：无法打印函数体（个人没找到），echo 变量名会打印函数名，而且函数的引用不能加$</li></ul><p>这些就是🐢的臀部--规定了，踩坑良久，献于诸君。我们来看看我说的那个vscode插件支持【一键输出打印语句】，目前支持js和shell。【如需试用可以搜索：weiyi-tools】</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64za8x97lg21fy0iktc4.gif" alt=""><figcaption>2022-09-13 14.27.53</figcaption></figure><h3 id="自动输出时期set">自动输出时期：set <a class="markdownIt-Anchor" href="#自动输出时期set">#</a></h3><p><code>set</code>命令用来修改 Shell 环境的运行参数，也就是可以定制环境。一共有十几个参数可以定制，<a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener">官方手册</a>有完整清单。</p><p>使用方式很简单，在脚本的顶部放上set命令+对应配置即可</p><pre class="hljs"><code>set -[...options]
</code></pre><p>具体配置如下</p><table><thead><tr><th>配置</th><th>不加时情况</th><th>加上后</th><th>补充</th></tr></thead><tbody><tr><td>u</td><td>如果遇到不存在的变量，Bash 默认忽略它。</td><td>遇到不存在的变量就会报错，并停止执行。</td><td>另一种写法<code>-o nounset</code>，两者是等价的。</td></tr><tr><td>x</td><td>屏幕只显示运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。</td><td>运行结果之前，先输出执行的那一行命令。</td><td>还有另一种写法-o xtrace。</td></tr><tr><td>e</td><td>有运行失败的命令（返回值非0），Bash 默认会继续执行后面的命令。</td><td>只要发生错误，就终止执行</td><td>等价-o errexit；这个一定要注意！！！因为我们的函数入出参是用非0实现的，如果加了这个就会中止了</td></tr><tr><td>o pipefail</td><td><code>-e</code>有一个例外情况，就是不适用于管道命令。</td><td>管道符链接的，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</td><td></td></tr></tbody></table><p>顺便提一下，如果命令行下不带任何参数，直接运行<code>set</code>，会显示所有的环境变量和 Shell 函数。</p><h5 id="常见使用方式">常见使用方式 <a class="markdownIt-Anchor" href="#常见使用方式">#</a></h5><p>将下面内容放在脚本顶部可以做到</p><ul><li>只要发生错误，就终止执行 （建议不用）</li><li>遇到不存在的变量就会报错，并停止执行。</li><li>运行结果之前，先输出执行的那一行命令。</li><li>管道符链接的，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</li></ul><pre class="hljs"><code><span class="hljs-built_in">set</span> -euxo pipefail
</code></pre><p>补充：其实本人还是喜欢下面这样就好啦，因为我会封装很多函数，如果加上了e就会导致中止</p><pre class="hljs"><code>set -ux
</code></pre><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64zui4vxpj2069069glk.jpg" alt=""><figcaption>avatar</figcaption></figure><h3 id="运行时处理时期debugger">运行时处理时期：debugger <a class="markdownIt-Anchor" href="#运行时处理时期debugger">#</a></h3><p>在这，会发现自动化时期其实并没有做到随时随地查看自己想看的运行状态，甚至还会打印很多很多不需要看的内容。有没有一种办法，可以直接图形化的查看当前调试状态下参数的值、卡住程序快照、逐步运行呢？聪明的小伙伴肯定想到了，这不就是debugger调试嘛。</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64zuxpd9oj20e60e6q3t.jpg" alt=""><figcaption>v2-86c9769b32e57b445651c9ddd1e9f409_720w</figcaption></figure><p>js我们肯定是可以的，shell呢？其实也可以，只是有几个小要求</p><ol><li>系统 bash 版本 &gt; 4.x (mac 自带版本为 3.2，需要手动升级)：<a href="https://liushiming.cn/article/upgrading-bash-on-macos.html" target="_blank" rel="noopener">参考Mac 升级最新版 bash</a></li><li>需要安装vsode的插件：bash debug</li><li>完成bash debug 插件配置文件，即launch.json文件</li></ol><p>这几步的动作原博主写的很赞，我就不赘述了，可见：<a href="https://liushiming.cn/article/debug-bash-on-macos.html%EF%BC%9B%E5%94%AF%E4%B8%80%E6%9C%89%E4%B8%80%E7%82%B9%E8%A1%A5%E5%85%85%E7%9A%84%E5%B0%B1%E6%98%AF%EF%BC%8C%E8%AE%B0%E5%BE%97%E6%8A%8Aprogram%E6%9B%BF%E6%8D%A2%E6%88%90" target="_blank" rel="noopener">https://liushiming.cn/article/debug-bash-on-macos.html；唯一有一点补充的就是，记得把program替换成</a><code>${file}</code>（原文复制下面的也可以），这代表要调试当前打开的shell文件。</p><pre class="hljs"><code>{
    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span>
    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span>
    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span>
    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,
    <span class="hljs-attr">&quot;configurations&quot;</span>: [
        {
            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;bashdb&quot;</span>,
            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,
            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bash-Debug (simplest configuration)&quot;</span>,
            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;${file}&quot;</span>
        }
    ]
}
</code></pre><p>最后，我们来看下效果</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64zc6c76gg21zj0u0wix.gif" alt=""><figcaption>2022-09-13 14.48.59</figcaption></figure><h3 id="关于个人的优化一键完成搭建动作">关于个人的优化：一键完成搭建动作 <a class="markdownIt-Anchor" href="#关于个人的优化一键完成搭建动作">#</a></h3><p>直接看效果【如需试用可以搜索：weiyi-tools】</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64zv4lp3eg21zm0ocqor.gif" alt=""><figcaption>2022-09-13 15.08.32</figcaption></figure><p>至此，shell之调试篇，完成。</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64zrmkpg0j20ho0hs74i.jpg" alt=""><figcaption>1651cbfd336d45bb12a38491cc85061d</figcaption></figure><h1 id="自实现vscode插件对shell的支持">自实现vscode插件对shell的支持 <a class="markdownIt-Anchor" href="#自实现vscode插件对shell的支持">#</a></h1><p>除此之外的内容</p><ul><li>vscode插件支持常见的shell snippet</li><li>vscode插件支持【属性.xxx】形式使用函数库</li></ul><p>写不动了，到时候另起一文，看下效果吧，对vscode插件开发想了解的同学也可以前往我的专栏查看：<a href="https://juejin.cn/column/7078626256777904165" target="_blank" rel="noopener">https://juejin.cn/column/7078626256777904165</a></p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6502xyr0ig20ft0brn1o.gif" alt=""><figcaption>6424dc224c0c0fcc28d71eca01277b8b</figcaption></figure><h1 id="尾声">尾声 <a class="markdownIt-Anchor" href="#尾声">#</a></h1><p>救命，内容实在是太多了，而且还有非常非常多踩的坑没有分享，开始以为能一文结束，写着写着才发现shell的世界浩如烟海，我只是抓住了一个角而已，还好，名字是带你走进这个世界，本文只能作为一个脉络文了，后续会根据本文进行拆分，输出一个专栏，希望同学们有遇到shell中有趣的知识点也能够留言和我分享。</p><p>老规矩，鸡汤一下</p><pre class="hljs"><code>当你埋头苦读的时候，阿拉斯加的鳕鱼正跃出水面，当你伏案写作的时候，南太平洋的海鸥正掠过海岸，当你认真工作的时候，地球的极圈正五彩斑斓，但梦要你亲自实现，那些你觉得看不到的人，和遇不到的风景，都终将在你生命里出现
</code></pre><p>每到一个新世界，都是一片新的美好风景，luck！</p><figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h64zr4p3klg204y04awkp.gif" alt=""><figcaption>thread_214569626974086_20201111224348_s_239569_o_w_178_h_154_73208</figcaption></figure><h1 id="常用文档">常用文档 <a class="markdownIt-Anchor" href="#常用文档">#</a></h1><ul><li>写给前端的 shell 脚本编程详解 - SegmentFault 思否：<a href="https://segmentfault.com/a/1190000037797344" target="_blank" rel="noopener">https://segmentfault.com/a/1190000037797344</a></li><li>Shell 流程控制 | 菜鸟教程：<a href="https://www.runoob.com/linux/linux-shell-process-control.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-shell-process-control.html</a></li><li>Shell字符串截取（非常详细）：<a href="http://c.biancheng.net/view/1120.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1120.html</a></li><li>Shell 脚本入门-阿里云开发者社区：<a href="https://developer.aliyun.com/learning/course/794?spm=a2c6h.21254954.graph.26.eabc4fe0ZUb86s" target="_blank" rel="noopener">https://developer.aliyun.com/learning/course/794?spm=a2c6h.21254954.graph.26.eabc4fe0ZUb86s</a></li><li>Shell：常用的语句整理-阿里云开发者社区：<a href="https://developer.aliyun.com/article/1007026?spm=a2c6h.21258778.0.0.6a4f39d26z0Qhx" target="_blank" rel="noopener">https://developer.aliyun.com/article/1007026?spm=a2c6h.21258778.0.0.6a4f39d26z0Qhx</a></li><li>Linux shell脚本之 if条件判断<em>doiido的博客-CSDN博客</em>shell的if判断语句：<a href="https://blog.csdn.net/doiido/article/details/43966819" target="_blank" rel="noopener">https://blog.csdn.net/doiido/article/details/43966819</a></li><li>Mac常用命令清单 - 掘金：<a href="https://juejin.cn/post/6844903608996069390" target="_blank" rel="noopener">https://juejin.cn/post/6844903608996069390</a></li><li>Shell 基础及实例 - 掘金：<a href="https://juejin.cn/post/6844903943886077960#heading-46" target="_blank" rel="noopener">https://juejin.cn/post/6844903943886077960#heading-46</a></li><li>shell 命令行参数（基本） - 苍青浪 - 博客园：<a href="https://www.cnblogs.com/cangqinglang/p/11942567.html" target="_blank" rel="noopener">https://www.cnblogs.com/cangqinglang/p/11942567.html</a></li><li>在 Shell 脚本中解析选项 | 始终：<a href="https://liam.page/2016/11/11/ways-to-parse-arguments-in-shell-script/" target="_blank" rel="noopener">https://liam.page/2016/11/11/ways-to-parse-arguments-in-shell-script/</a></li><li>浅谈shell 遍历数组的几种方法 - 编程宝库：<a href="http://www.codebaoku.com/it-shell/it-shell-201789.html" target="_blank" rel="noopener">http://www.codebaoku.com/it-shell/it-shell-201789.html</a></li><li>使用vscode调试bash脚本：<a href="https://liushiming.cn/article/debug-bash-on-macos.html" target="_blank" rel="noopener">https://liushiming.cn/article/debug-bash-on-macos.html</a></li><li>Mac安装新版本Bash | Happy Hack Everday：<a href="https://blog.happyhack.io/2020/07/16/upgrade-bash-on-macOS/" target="_blank" rel="noopener">https://blog.happyhack.io/2020/07/16/upgrade-bash-on-macOS/</a></li><li>Linux：查看占用 cpu/内存 资源最多的进程并杀死：<a href="https://blog.csdn.net/qq_41538097/article/details/107539714" target="_blank" rel="noopener">https://blog.csdn.net/qq_41538097/article/details/107539714</a></li><li>Bash 脚本 set 命令教程：<a href="https://www.ruanyifeng.com/blog/2017/11/bash-set.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2017/11/bash-set.html</a></li></ul></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../shell编程训练营/3. Shell 的函数、模块化、公共函数库.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../shell编程训练营/开营前置信息.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.24</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../shell编程训练营/index.html">shell编程训练营</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../shell编程训练营/1. Shell 的基本介绍、常用命令以及 Shell 的流程控制.html">我们为什么要学习shell</a></li><li class="chapter-item"><a href="../shell编程训练营/2. Shell 中的数组应用、参数处理和函数的应用.html">shell之语句</a></li><li class="chapter-item"><a href="../shell编程训练营/3. Shell 的函数、模块化、公共函数库.html">shell之函数</a></li><li class="chapter-item chapter-item-current"><a href="../shell编程训练营/4. Shell周边：语言特殊点调试 Debug 方案vscode对shell的支持.html">语言特殊点</a></li><li class="chapter-item"><a href="../shell编程训练营/开营前置信息.html">开营前置信息.md</a></li></ul><li class="chapter-item"><a href="../vscode训练营/index.html">vscode训练营</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../vscode训练营/day1：简单了解插件开发.html">day1：简单了解插件开发.md</a></li><li class="chapter-item"><a href="../vscode训练营/day2：实现一个简单代码工具.html">day2：实现一个简单代码工具.md</a></li><li class="chapter-item"><a href="../vscode训练营/day3：vscode配置文件.html">day3：vscode配置文件.md</a></li><li class="chapter-item"><a href="../vscode训练营/day4：完善工具，添加更多功能并发布.html">然后输入之前获取到的 token</a></li><li class="chapter-item"><a href="../vscode训练营/开营计划.html">开营计划.md</a></li></ul><li class="chapter-item"><a href="../webpack插件训练营/index.html">webpack插件训练营</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../webpack插件训练营/day1. 简单了解webpack.html">day1. 简单了解webpack.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day2. webpack配置文件拆分及开发环境搭建.html">day2. webpack配置文件拆分及开发环境搭建.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day3. 文件类型处理篇.html">day3. 文件类型处理篇.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day4. 性能分析篇.html">day4. 性能分析篇.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day5. 性能优化篇：体积优化.html">day5. 性能优化篇：体积优化.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day6. 性能优化篇：缓存.html">day6. 性能优化篇：缓存.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day7. webpack 核心工作流程.html">day7. webpack 核心工作流程.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/day8. 熟悉插件和loader的发布流程.html">day8. 熟悉插件和loader的发布流程.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/开营计划.html">开营计划.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/提效技巧篇：px转rem.html">提效技巧篇：px转rem.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/提效技巧篇：基于glob实现自动化路由的MPA.html">提效技巧篇：基于glob实现自动化路由的MPA.md</a></li><li class="chapter-item"><a href="../webpack插件训练营/提效技巧篇：浏览器前缀自动添加.html">提效技巧篇：浏览器前缀自动添加.md</a></li></ul><li class="chapter-item"><a href="../前端爬虫/index.html">前端爬虫</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../前端爬虫/1. 了解爬虫 - puppetter实战.html">1. 了解爬虫 - puppetter实战.md</a></li><li class="chapter-item"><a href="../前端爬虫/2. 数据入库.html">2. 数据入库.md</a></li><li class="chapter-item"><a href="../前端爬虫/3. 展示应用实现.html">3. 展示应用实现.md</a></li><li class="chapter-item"><a href="../前端爬虫/4. 实战：kkb一键爬取所有vip课程.html">4. 实战：kkb一键爬取所有vip课程.md</a></li><li class="chapter-item"><a href="../前端爬虫/开营计划.html">开营计划.md</a></li></ul></ul><li class="chapter-item"><a href="../学习小组规划.html">学习小组规划.md</a></li><li class="chapter-item"><a href="../开营计划.html">开营计划.md</a></li><li class="chapter-item"><a href="../模板.html">模板.md</a></li><li class="chapter-item"><a href="../谷歌浏览器插件/index.html">谷歌浏览器插件</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../谷歌浏览器插件/开营计划.html">开营计划.md</a></li></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"shell编程训练营/4. Shell周边：语言特殊点调试 Debug 方案vscode对shell的支持.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E8%84%9A%E6%9C%AC%E6%8E%A7%E5%88%B6">脚本控制</a>\n<ul>\n<li><a href="#%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7">捕获信号</a></li>\n</ul>\n</li>\n<li><a href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1">计划任务</a>\n<ul>\n<li><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1">一次性计划任务</a></li>\n<li><a href="#%E5%91%A8%E6%9C%9F%E6%80%A7%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1cron">周期性计划任务：cron</a></li>\n<li><a href="#crontab%E7%A4%BA%E4%BE%8B">crontab示例</a></li>\n<li><a href="#%E5%BB%B6%E6%97%B6%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1anacontab">延时计划任务：anacontab</a></li>\n<li><a href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%8A%A0%E9%94%81flock">计划任务加锁：flock</a></li>\n</ul>\n</li>\n<li><a href="#%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5%E7%AE%A1%E9%81%93">重点概念：管道</a></li>\n<li><a href="#%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5%E9%87%8D%E5%AE%9A%E5%90%91">重点概念：重定向</a>\n<ul>\n<li><a href="#%E5%85%B7%E4%BD%93%E6%95%B4%E7%90%86">具体整理</a></li>\n<li><a href="#%E6%A1%88%E4%BE%8B-1">案例</a></li>\n<li><a href="#log%E6%97%B6%E6%9C%9F">log时期</a></li>\n<li><a href="#%E8%87%AA%E5%8A%A8%E8%BE%93%E5%87%BA%E6%97%B6%E6%9C%9Fset">自动输出时期：set</a></li>\n<li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%84%E7%90%86%E6%97%B6%E6%9C%9Fdebugger">运行时处理时期：debugger</a></li>\n<li><a href="#%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%80%E9%94%AE%E5%AE%8C%E6%88%90%E6%90%AD%E5%BB%BA%E5%8A%A8%E4%BD%9C">关于个人的优化：一键完成搭建动作</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>