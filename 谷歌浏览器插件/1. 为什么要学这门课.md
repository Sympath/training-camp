## 为什么要学 Chrome 扩展

1. Chrome 扩展插件的技术开发知识
2. 通过扩展插件开发出自己的效率工具，打造自己的趁手利器
3. 开发出自己的产品，打造自己的赚钱工具

## 实现目录

1. 入门 DEMO
2. 核心机制：核心文件/消息通信
3. 开发调试：开发安装/错误调试
4. 打包发布
5. Chrome 高级特性：数据存储/跨域访问/扩展内页面/多语言/background/选项页面
6. 框架升级：Vue 开发
7. 注意事项：CSP/审核被拒

## 入门 DEMO

目录结构

```
.
|-- img
|   |-- icon.png
|-- js
|   |-- content.js
|-- manifest.json
|-- popup.html
|-- popup.js
```

首先在 popup.html 中实现下 dom 结构

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Hello wangzy chrome</title>
    <script src="popup.js"></script>
    <style>
      body {
        width: 360px;
        height: 200px;
        text-align: center;
        padding: 15px;
      }
      .btn {
        text-align: center;
        cursor: pointer;
        width: 160px;
        padding: 10px 25px;
        border-color: 3px;
        margin: 0px auto;
        display: block;
        background-color: #0f88eb;
        color: white;
        font-size: 14px;
      }
    </style>
  </head>
  <body id="status">
    <div id="getResults" class="btn">点击探索</div>
    <div id="results"></div>
  </body>
</html>
```

然后实现下逻辑

1. 当点击按钮时，获取当前活动 Tab 窗口，并发送消息到 content_script
2. 获取从 content_script 的返回结果并显示
3. content_script.js 中接受监听收到的消息，根据 action 来分别处理，然后回传
   popup.js 的内容如下

```js
// 在popup.html的页面里，Dom内容加载完毕后执行
document.addEventListener("DOMContentLoaded", function (event) {
  var resultsButton = document.getElementById("getResults");
  resultsButton.onclick = getResults;
});
// 当点击按钮时，获取当前活动Tab窗口，并发送消息到content_script
function getResults() {
  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
    chrome.tabs.sendMessage(
      tabs[0].id,
      { action: "checkForContent" },
      function (response) {
        showResults(response.results);
      }
    );
  });
}
// 获取从content_script的返回结果
function showResults(results) {
  var resultsElement = document.getElementById("results");
  resultsElement.innerText = results ? results : "没有收到content script的内容";
}
```

js/content_script.js 的内容如下

```js
// 监听收到的消息，根据action来分别处理
chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
  if (request.action === "checkForContent") {
    checkForContent(request, sender, sendResponse);
    return true;
  }
});

// 返回值处理
function checkForContent(request, sender, sendResponse) {
  return sendResponse({
    results:
      "Hello World! 我是来自「" +
      document.title +
      "」content script世界的消息~",
  });
}
```



## 核心机制

### 项目组成

- manifest.json
- background.js
- Popup.js
- Content-script.js
- popup.html



### 消息通信

![image-20220919071541117](https://tva1.sinaimg.cn/large/e6c9d24ely1h6bjvp3rumj20lq0f5mxr.jpg)

##### 一次性简单消息通信

content和popup

![image-20220919074634543](https://tva1.sinaimg.cn/large/e6c9d24ely1h6bkru3sdcj211k0ettay.jpg)

- 如果多个页面都在发起请求，只有第一个页面会被响应到



##### 长链接模式

chrome.runtime.Port对象

![image-20220919074944823](https://tva1.sinaimg.cn/large/e6c9d24ely1h6bkv4ztbwj212m0etacx.jpg)





##### 扩展程序间通信模式



##### 接受指定页面发送到消息

![image-20220919091317750](https://tva1.sinaimg.cn/large/e6c9d24ely1h6bnestsp4j20wi0awwfi.jpg)

## 开发-调试-打包发布

### 安装插件

![image-20220919091841753](https://tva1.sinaimg.cn/large/e6c9d24ely1h6bnfrlrgsj217e0go0us.jpg)

### 开发调试



### 打包发布

1. 开发者注册：需要支付5美元的一次性费用，注册完成后就可以上传了，注册地址：https://chrome.google.com/webstore/devconsole/register
2. 打包上传：将项目压缩成.zip的文件，准备上传，登陆chrome应用的开发者中心：https://chrome.google.com/webstore



## 数据存储

- html5的localStorage ：实现本地存储
- google的chrome.storage ：实现浏览器存储
- google的chrome.chookies：实现cookie存储

### chrome.storage ：实现浏览器存储

常用的两类为【chrome.storage.sync】和【chrome.storage.local】

- local：只能将数据存储在当前登陆的设备本地，大小限制为5M。如果声明权限为unlimitedStorage则不受大小限制
- sync：实现了自动数据同步，相同的用户无论使用什么物理设置，只要以相同的账户登陆即可访问存储的数据，大小限制为100kb。

![image-20220920004332141](https://tva1.sinaimg.cn/large/e6c9d24ely1h6ce61wfw4j211f093my3.jpg)

### chrome.chookies：实现cookie存储

可以获取或修改cookie，监控cookie的变化

![image-20220920004434876](https://tva1.sinaimg.cn/large/e6c9d24ely1h6ce73h4duj20nn0fe3zh.jpg)

## 跨域访问

基于安全协议，XMLHttpRequest不能访问其他域的服务器，但扩展没有这个限制，前提是设置了访问权限

![image-20220920004644824](https://tva1.sinaimg.cn/large/e6c9d24ely1h6ce9cylmhj210f0dqq4m.jpg)



## 扩展内页面

思考如何打开扩展内的html页面（ chrome.extension.getURL是将扩展程序安装目录中的相对路径转换为完整的URL）

- window.open + chrome.extension.getURL(string path)：打开新窗口页面
- chrome.tabs.create  +   chrome.extension.getURL(string path)：创建新的tab页打开
- chrome-extension://extensionId/filename

![image-20220920005323586](https://tva1.sinaimg.cn/large/e6c9d24ely1h6ceg9jnnwj20ll05k3yt.jpg)

![image-20220920005336739](https://tva1.sinaimg.cn/large/e6c9d24ely1h6ceghskdyj20j60730sy.jpg)

## 多语言

### 配置

1. 需要把所有用户可见字符串保存在文件名为`message.json`文件中
2. 文件位于项目根目录下的_locales\locale_Code,其中的local_Code有专门的国际标准规定（比如简体中文是zh_CN）
3. 一旦有_locales目录就必须在manifest.json文件中指定默认Locale

![image-20220920005649458](https://tva1.sinaimg.cn/large/e6c9d24ely1h6ceju9re6j20zk06f74m.jpg)

### 引用

![image-20220920005747775](https://tva1.sinaimg.cn/large/e6c9d24ely1h6cekut7xmj211f0hf766.jpg)

##### 预定义资源

![image-20220920005856034](https://tva1.sinaimg.cn/large/e6c9d24ely1h6cem1i7lgj20yl0h1jt9.jpg)

## background

### 特点

1. 在manifiest.json文件中通过background指定js文件
2. 扩展被安装后会一直运行在浏览器程序中

### 配置

1. 一般仅需要js文件，也支持指定html，用于背景页
2. persistent属性定义了常驻后台的方式，如果是true则会一直运行，无论扩展是不是在工作；为false时表示按需运行（Event Page）

![image-20220920010116811](https://tva1.sinaimg.cn/large/e6c9d24ely1h6ceogzpe1j20sn05gmxd.jpg)

3. 在popup中可以通过`chrome.extension.getBackgroundPage()`获取后台对象，从而执行后台行为

![image-20220920010136883](https://tva1.sinaimg.cn/large/e6c9d24ely1h6ceothvwnj20lz05a0t3.jpg)

### 调试

后台脚本 background script 是运行在 Service workers 中，它没有页面，如果希望打开它的开发者工具，可以在 chrome://extensions 扩展程序管理页面找到相应的扩展程序卡片，点击里面的「背景页」链接，就可以打开后台脚本的开发者工具

![background-debug.png](https://tva1.sinaimg.cn/large/e6c9d24ely1h6e8m2evopj20ui094wfj.jpg)

### DEMO：合并浏览器窗口

点击扩展时，实现将所有窗口等tab页合并到当前窗口，思路如下
1. 监听图标点击事件

2. 获取当前窗口，作为目标窗口

3. 要进行tab页的迁移，需要条件【被迁移tab页id / 指定目标窗口id / 指定目标索引（放在第几个位置）】，然后使用chrome.tabs.move实现迁移即可。

  1. 被迁移tab页id：通过chrome.windows.getAll获取所有窗口，再通过窗口对象的tabs属性获取对应tab对象
  2. 指定目标窗口id：通过chrome.windows.getCurrent获取目标窗口

  3. 指定目标索引：起始位置是当前窗口的tab数；然后每次+1就是目标

最后实现的代码如下

##### 回调版本

```js
let targetWindow = null; //当前激活的浏览器窗口
let tabCount = 0; //当前激活浏览器窗口里的tab的数量

/**
 * 点击浏览器图标绑定的事件
 * @param tab
 */
function start(tab) {
  chrome.windows.getCurrent(getWindows)
}
function getWindows(win) {
  targetWindow = win;
  chrome.tabs.getAllInWindow(targetWindow.id, getTabs);
}
function getTabs(tabs) {
  tabCount = tabs.length;
  chrome.windows.getAll({ "populate": true }, moveTabs);
}
function moveTabs(windows) {
  var numWindows = windows.length;
  var tabPosition = tabCount;
  for (var i = 0; i < numWindows; i++) {
    var win = windows[i];
    if (targetWindow.id != win.id) {
      var numTabs = win.tabs.length;
      for (var j = 0; j < numTabs; j++) {
        var tab = win.tabs[j];
        chrome.tabs.move(tab.id, { "windowId": targetWindow.id, "index": tabPosition });
        tabPosition++;
      }
    }
  }
}
// 地址栏图标绑定点击事件
chrome.browserAction.onClicked.addListener(start);
```

##### promise版本

可以看到，上面的代码时经典的回调式编程，就我个人而言，是更推崇，以promise连接的同步式编程的；那怎么优化呢？回想下node中是不是有个工具包utils支持了promisify，用于将回调转为promise，我们是浏览器环境没法直接用，但我们也可以参考思路实现一个针对谷歌扩展的呀，授人以鱼不如授人以渔，开干！

```js
function promisify(cb) {
    return function (...params) {
        return new Promise((res, rej) => {
            cb(...params, function (result) {
                res(result)
            })
        })
    }
}
let funNames = [
    {
        chromeName: 'windows',
        funName: 'getCurrent'
    },
    {
        chromeName: 'windows',
        funName: 'getAll'
    },
    {
        chromeName: 'tabs',
        funName: 'getAllInWindow'
    }
]
funNames.forEach(({ chromeName, funName }) => {
    chrome[chromeName][funName] = promisify(chrome[chromeName][funName])
})
```

其实就是原型链覆盖，很好理解吧～我们看看效果

```js

let targetWindow = null; //当前激活的浏览器窗口
let tabCount = 0; //当前激活浏览器窗口里的tab的数量
/**
 * 点击浏览器图标绑定的事件
 * @param tab
 */
chrome.browserAction.onClicked.addListener(async (tab) => {
    let targetWindow = await chrome.windows.getCurrent()
    let tabs = await chrome.tabs.getAllInWindow(targetWindow.id);
    tabCount = tabs.length;
    // 如果populate是true表示每个视窗对象都有一个包含该视窗所有标签的tabs属性。
    let windows = await chrome.windows.getAll({ "populate": true })
    var numWindows = windows.length;
    var tabPosition = tabCount;
    for (var i = 0; i < numWindows; i++) {
        var win = windows[i];
        if (targetWindow.id != win.id) {
            var numTabs = win.tabs.length;
            for (var j = 0; j < numTabs; j++) {
                var tab = win.tabs[j];
                chrome.tabs.move(tab.id, { "windowId": targetWindow.id, "index": tabPosition });
                tabPosition++;
            }
        }

    }
});
```

我个人是觉得更优雅了，仁者见仁智者见智啦。

##### 实现效果

话不多说，让我们看看效果

![2022-09-21 20.05.04](https://tva1.sinaimg.cn/large/e6c9d24ely1h6ehhs4kx1g21sk0u0wuq.gif)



## 选项页面：实现定时提醒

有时我们需要让用户自定义一些内容，这时我们就需要通过选项页面实现了。

这里的定时自然需要用户指定间隔时间，所以我们需要用到选项页

对应menafest配置

```
"options_page": "options.html"
```

提醒逻辑要常驻后台，所以需要实现在background中，且需要提醒权限，所以对应配置如下

```
permission: [
  "notification"
]
background: {
  "script": "background.jss"
}
```



## 高级开发指南：结合vue

- vue环境搭建
- chrome扩展的Tab页面Overide功能
- Ajax请求第三方接口
- Vue的热更新开发
- 实战：一图一诗，每新开一个tab，就打开一张背景图和对应一首诗。

有没有发现，无论怎么样，我们都还是在用三大件去开发：html/css/js，用习惯了框架的我们，怎么还能接受这刀耕火种的时代。其实我们要的不是抛弃三大件，而是开发用便捷的框架，产物还是html/css/js，这就很像我之前分享shell时觉得特别特别喜欢的封装了。（有兴趣的同学可见）



## 自己的vue开发chrome扩展脚手架





## 如何盈利

基于Chrome扩展的盈利方式主要有

- 上传付费的扩展
- 扩展内嵌广告
- 产品内付费
- 打赏

```
从很小的角度切入，抓住一些细分市场的需求，快速形成一个可以赚钱的产品
```

### 实战：微信群合影

##### 效果

网站介绍页

![image-20220922105907196](https://tva1.sinaimg.cn/large/e6c9d24ely1h6f773up2tj20pu0b4751.jpg)

成效

![image-20220922105628809](https://tva1.sinaimg.cn/large/e6c9d24ely1h6f74fubhkj20cs0j4wie.jpg)

##### 开发

- 页面page.js获取图片头像url后，发送消息到popup.js，popup.html内绘制图形

- 构建账号体系，实现收费用户和普通用户的区别，后台采用LeanCloud（免费版）

- 网站介绍页：阿里云国际域名（55元），github page搭建

  
